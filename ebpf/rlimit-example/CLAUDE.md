# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is an eBPF example demonstrating how to trace execve system calls while handling RLIMIT_MEMLOCK restrictions. It's part of a larger collection of experiments in the slog repository.

## Architecture

The project uses the libbpf BPF CO-RE (Compile Once, Run Everywhere) approach with two main components:

1. **Kernel-space BPF program** (`exec.bpf.c`): Attaches to the `sys_enter_execve` tracepoint and logs executed filenames using `bpf_printk`

2. **Userspace loader** (`exec.c`): Loads and attaches the BPF program using the skeleton API. Includes a critical `bump_memlock_rlimit()` function that sets RLIMIT_MEMLOCK to RLIM_INFINITY to allow BPF map/program loading.

3. **Generated skeleton header** (`exec.skel.h`): Auto-generated by bpftool from the compiled BPF object, providing the `exec__open()`, `exec__load()`, and `exec__attach()` functions.

4. **vmlinux.h**: BTF-based kernel type definitions for BPF programs, generated from the running kernel.

## Build Process

### Using CMake (Recommended)

```bash
# Configure the build
mkdir build && cd build
cmake ..

# Build all artifacts (BPF program, skeleton, and executable)
cmake --build .

# The executable will be at build/exec
```

### Manual Build

The build requires three compilation steps:

```bash
# Step 1: Compile the BPF program to BPF bytecode
clang -O2 -g -target bpf -D__TARGET_ARCH_x86 -c exec.bpf.c -o exec.bpf.o

# Step 2: Generate the skeleton header from the BPF object
bpftool gen skeleton exec.bpf.o > exec.skel.h

# Step 3: Compile the userspace program linking against libbpf
gcc -o exec exec.c -lbpf
```

Or in one command:
```bash
clang -O2 -g -target bpf -D__TARGET_ARCH_x86 -c exec.bpf.c -o exec.bpf.o && bpftool gen skeleton exec.bpf.o > exec.skel.h && gcc -o exec exec.c -lbpf
```

### CMake Build System Details

The CMakeLists.txt automates the entire build pipeline:
1. Detects target architecture (x86_64 → x86, aarch64 → arm64)
2. Compiles the BPF program with clang to BPF bytecode
3. Generates the skeleton header using bpftool
4. Compiles the userspace program and links against libbpf
5. Manages dependencies so skeleton generation happens before C compilation

## Running

Requires root privileges:
```bash
# If built with CMake
sudo ./build/exec

# If built manually
sudo ./exec
```

Output is viewed via the kernel trace pipe:
```bash
sudo cat /sys/kernel/debug/tracing/trace_pipe
```

## Key Patterns

### RLIMIT_MEMLOCK Handling
The `bump_memlock_rlimit()` function is essential - without it, BPF map and program loading will fail due to locked memory limits. This pattern is common in BPF programs that don't have CAP_BPF capability.

### Skeleton API Usage
The generated skeleton provides a type-safe API:
- `exec__open()`: Opens BPF object
- `exec__load()`: Loads programs and maps into kernel
- `exec__attach()`: Attaches programs to hooks

### Tracepoint Attachment
Uses `SEC("tp/syscalls/sys_enter_execve")` to attach to the execve entry tracepoint. The context type `struct trace_event_raw_sys_enter` provides access to syscall arguments via `ctx->args[]`.

## Dependencies

- Linux kernel with BPF support (4.15+)
- CMake (3.16+)
- clang (for BPF compilation)
- gcc (for userspace compilation)
- libbpf and libbpf-dev
- bpftool (for skeleton generation)
- Root/CAP_BPF/CAP_PERFMON privileges (for running)

## Related Examples

The sibling directory `helloworld_perf/` contains a more complex example using perf events for CPU profiling with eBPF, demonstrating perf event setup and BPF maps for tracking per-PID sample counts.
